{"meta":{"title":"小雄子的博客","subtitle":"编程的点点滴滴","description":"每多学一点知识，就能少写一点代码","author":null,"url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-05-21T17:31:57.000Z","updated":"2017-05-21T18:08:40.286Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-21T17:53:57.000Z","updated":"2017-05-21T18:08:54.142Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2017-05-21T17:54:40.000Z","updated":"2017-05-21T17:56:56.362Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""}],"posts":[{"title":"Canvas开发FlappyBird小游戏","slug":"FlappyBird","date":"2017-09-11T04:55:59.852Z","updated":"2017-09-11T04:56:21.095Z","comments":true,"path":"2017/09/11/FlappyBird/","link":"","permalink":"http://yoursite.com/2017/09/11/FlappyBird/","excerpt":"","text":"原生JavaScript和Canvas实现FlappyBird小游戏 项目地址→传送门 点击这里开始游戏 PS:可以以电脑浏览器的手机模式打开，也可以在手机浏览器中直接打开 游戏运用了Canvas的drawImage，translate，rotate，save，restore，fillRect等API。采用中介者模式，Game类统领全局，负责读取资源，设置定时器，维护各个物体实例，所有的演员都是Game类new 出来的， 游戏项目外部的语句就一条：1var game = new Game(); 其他的所有语句都封装在Game类里面了需要的类： Game类：中介者，读取资源，设置定时器，维护各个物体实例 Bird类：小鸟类，这个类是单例的，实例化一次 Pipe类： 管子类 Land类：大地类 BG类：背景类 sceneManager类：场景管理类 难点 视口的适配 我们的游戏在任何手机上面都是充满视口的这里贴出代码1234567891011121314151617181920212223(function () &#123; var Game = window.Game = function (id) &#123; this.canvas = document.querySelector(id); this.context = this.canvas.getContext('2d'); this.init() &#125; Game.prototype.init = function () &#123; var windowW = document.documentElement.clientWidth; var windowH = document.documentElement.clientHeight; if (windowW &gt; 414) &#123; windowW = 414; &#125; else if (windowW &lt; 320) &#123; windowW = 320; &#125; if (windowH &gt; 736) &#123; windowH = 736 &#125; else if (windowH &lt; 500) &#123; windowH = 500; &#125; this.canvas.width = windowW; this.canvas.height = windowH &#125;&#125;)() 资源管理器 游戏中有多张图片，这些图片都必须先load后，然后才能让定时器开始工作。我们可以自己创建一个资源管理器，主要目的是为了读取外部的配置文件，游戏中的资源管理器R.json文件。存储了游戏中需要的图片对象。游戏所需要的图片在这里下载飞翔的小鸟(Flappy Bird)素材 碰撞检测 因此小鸟的图片其实是一个长方形，而且角度又不断变化导致中心点难于掌握，因此很难判断小鸟与管子的碰撞。这里画了张图帮助自己理解 小鸟下落的速度 需要模拟小鸟的重力，高中物理没有白学 分数的计算 分数的计算与碰撞检测类似，设置一个开关，当管子重新出现时，设置为true。当分值加1时，设置为false。小鸟的最左边的x坐标如果超出了管子的x+width，就认为成功通过。 场景管理器 场景管理器有4个方法enter,update,render，bindEvent。其中定时器在每帧执行update方法和render方法。enter方法由业务来调用，比如用户点击了按钮，此时就进入场景2，鸟撞到了管子，就进入场景3。 这样就把游戏的各个不同阶段分离出来，方便处理。 FlappyBird原生JavaScript和Canvas实现FlappyBird小游戏点击这里开始游戏PS:可以以电脑浏览器的手机模式打开，也可以在手机浏览器中直接打开 游戏运用了Canvas的drawImage，translate，rotate，save，restore，fillRect等API。采用中介者模式，Game类统领全局，负责读取资源，设置定时器，维护各个物体实例，所有的演员都是Game类new 出来的， 游戏项目外部的语句就一条：1var game = new Game(); 其他的所有语句都封装在Game类里面了需要的类： Game类：中介者，读取资源，设置定时器，维护各个物体实例 Bird类：小鸟类，这个类是单例的，实例化一次 Pipe类： 管子类 Land类：大地类 BG类：背景类 sceneManager类：场景管理类 难点 视口的适配 我们的游戏在任何手机上面都是充满视口的这里贴出代码1234567891011121314151617181920212223(function () &#123;var Game = window.Game = function (id) &#123;this.canvas = document.querySelector(id);this.context = this.canvas.getContext('2d');this.init()&#125;Game.prototype.init = function () &#123;var windowW = document.documentElement.clientWidth;var windowH = document.documentElement.clientHeight;if (windowW &gt; 414) &#123;windowW = 414;&#125; else if (windowW &lt; 320) &#123;windowW = 320;&#125;if (windowH &gt; 736) &#123;windowH = 736&#125; else if (windowH &lt; 500) &#123;windowH = 500;&#125;this.canvas.width = windowW;this.canvas.height = windowH&#125;&#125;)() 资源管理器 游戏中有多张图片，这些图片都必须先load后，然后才能让定时器开始工作。我们可以自己创建一个资源管理器，主要目的是为了读取外部的配置文件，游戏中的资源管理器R.json文件。存储了游戏中需要的图片对象。游戏所需要的图片在这里下载飞翔的小鸟(Flappy Bird)素材 碰撞检测 因此小鸟的图片其实是一个长方形，而且角度又不断变化导致中心点难于掌握，因此很难判断小鸟与管子的碰撞。这里画了张图帮助自己理解 小鸟下落的速度 需要模拟小鸟的重力，高中物理没有白学 分数的计算 分数的计算与碰撞检测类似，设置一个开关，当管子重新出现时，设置为true。当分值加1时，设置为false。小鸟的最左边的x坐标如果超出了管子的x+width，就认为成功通过。 场景管理器 场景管理器有4个方法enter,update,render，bindEvent。其中定时器在每帧执行update方法和render方法。enter方法由业务来调用，比如用户点击了按钮，此时就进入场景2，鸟撞到了管子，就进入场景3。 这样就把游戏的各个不同阶段分离出来，方便处理。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"JavaScript面向对象笔试汇总(1)","slug":"JavaScript面向对象笔试汇总（1）","date":"2017-09-07T16:10:13.813Z","updated":"2017-09-07T16:11:15.921Z","comments":true,"path":"2017/09/08/JavaScript面向对象笔试汇总（1）/","link":"","permalink":"http://yoursite.com/2017/09/08/JavaScript面向对象笔试汇总（1）/","excerpt":"","text":"程序运行后，输出为何？1234567891011function fun()&#123; var a =1; this.a = 2; function fn()&#123; return this.a; &#125; fn.a = 3; return fn;&#125;var result = fn()();console.log(result); 解析：var a = 1 是一个局部变量，此时fun()是典型的函数直接加圆括号，所以函数的上下文就是window对象。第3行this.a就表示给全局增加了一个a属性，值为2。第一次fun()返回一个内存函数，第二次fun()也是典型的函数直接加圆括号，所以上下文也是window对象。此时运行，返回window.a，因为第一次运行已经给全局设置了a值为2，所以result的结果最终为2。 如何在函数内部得到函数自身的属性1234function f()&#123; //如何在里面获得函数f的属性a&#125;f.a = 100; 做法就是：12345function f()&#123; alert(arguments.callee.a);&#125;f.a = 100;f(); 也可以这样：12345function f()&#123; alert(this.a)&#125;f.a = 100;f.call(f); 考察数组枚举调用函数1234567891011var arr = [fn1,fn2];function fn1()&#123; return this.length;&#125;function fn2() &#123; return this[0]&#125;var a = arr[0]();var b = arr[1]()();console.log(a);console.log(b); 首先看语句arr[0]()，此时是数组枚举出函数，然后调用，所以函数里面的this是数组，也就是this.length要返回的是数组的长度2。第二条语句arr[1]()()表示fn2()运行得到的结果再运行，此时看一下arr[1](),表示的是数组枚举出来然后运行，此时函数里面的this是数组，返回fn1。第二个圆括号就是fn1直接加圆括号运行，this就是window对象，此时window的length属性值为0(测试为0，具体原因不清楚)。因此最终的输出结果使2和0。 程序运行后，输出什么123456789101112131415var a = 1;var obj = &#123; a : 2, fn : (function () &#123; this.a = 3; return function()&#123; return this.a; &#125; &#125;)()&#125;var fn = obj.fn;var result1 = obj.fn();var result2 = fn();console.log(result1);console.log(result2); 解析：首先我们得明白IIFE的执行时机是什么，就是一个对象定义的时候，如果值时表达式，那么在定义的时候，就已经执行掉了，比如下面的程序，先弹出”你好”，再弹出”么么哒”123456var obj = &#123; a : (function()&#123; alert(\"你好\") &#125;)()&#125;alert(\"么么哒\"); 再看我们的题目，程序执行到第5行的IIFE时，this表示window对象，此时全局的a属性就变成了3。第12行，obj.fn() ，this指向obj。此时a为2。第13行，var fn = obj.fn(),再执行fn() ，此时this就是window对象，因此结果为2和3。 给页面上的方形盒子添加onmousemove事件监听，请在图中画出表示event.clientY值的线段并标注1，画出document.documentElement.clientHeight的线段并标注2，画出document.body.scrollTop的线段并标注3： 以下程序会弹出什么 12345678910function fun1()&#123; fun2(arguments)&#125;function fun2(a,b,c,d)&#123; alert(\"a\"); alert(\"b\"); alert(\"c\"); alert(\"d\");&#125;fun1(1,2,3,4) 依次弹出[object Argument]，undefined，undefined，undefined。因为第一行的arguments实际上是一个类数组。要想取得预期的效果，可以这样改：12345678910function fun1()&#123; fun2.apply(null,arguments)&#125;function fun2(a,b,c,d)&#123; alert(\"a\"); alert(\"b\"); alert(\"c\"); alert(\"d\");&#125;fun1(1,2,3,4) apply的妙处就是能打开数组,比如可以用来求数组的最大值12var arr = [2,324,32,536,863,456]Math.max.apply(null,[arr]) 程序运行2000毫秒后，控制台输出什么？12345678910var a = 1；function fun()&#123; var a = 2; this.a = 3;&#125;setTimeout(function()&#123; var a = 4; fun(); console.log(this.a);&#125;,2000) 输出的结果是3，因为第8行执行fun()的时候，this指向的是window，调到第四行改变了a的值，所以this.a为3。 试写出程序执行的结果： 12345678910function fun(fn,arg1,arg2,arg3)&#123; arguments[0](1,2,3)&#125;function fun2(m,n)&#123; alert(this.length); alert(this.callee.length); alert(arguments.length); alert(arguments.callee.length)&#125;fun(fun2); 分别弹出1,4,3,2解析：第一个alert中的this指向arguments类数组的本身，此时arguments的长度为1，就是fun(fun2)的实参fun2。第二个this.callee.length指向的是fun的形参fun(fn,arg1,arg2,arg3)的长度，所以为4。第三个arguments.length是arguments[0](1,2,3)实参的长度，所以为3。第四个arguments.callee.length是fun2(m,n)的形参的长度，所以为2。 试写出程序的执行结果1234567891011121314151617181920var m = 10;var obj1 = &#123; m : 20, fn : (function()&#123; this.m *= 2; m = 5; //注意这里并没有把window的属性m改为5，因为它的下一行有变量声明提升的作用 var m = 6;//，所以第6行改的实际上是闭包里面的m值 return function()&#123; this.m *= m; console.log(this.m); &#125; &#125;)()&#125;;var obj2 = &#123; m : 30&#125;;var fn = obj1.fn;fn();obj.fn();obj.fn.call(obj2); 这道题考了闭包，this的指向，变量声明提升，立即执行函数。输出结果依次为 120 ， 120， 180 。不解释了，看注释 试写出程序执行的结果 1234console.log(Object instanceof Object);console.log(Function instanceof Function);console.log(String instanceof String);console.log(Function instanceof Object); 分析： 任何函数都是Function new出来的。包括Object，Function也是Function new出来的。 a instanceof A ，就要看A的prototype是不是在a 的原型链上。 答案为：true ，true ，false，false，true 试写出程序执行的结果 12345678910function Fun()&#123; this.a = 5; function fun()&#123; this.a = 10; &#125; fun.a = 15; return fun;&#125;var o = new(new Fun());console.log(o.a); 解析：结果为10首先我们要理解new一个函数实例的过程。第一次new Fun()的时候，并且return的是引用类型值，所以函数返回的就是里面的fun函数，此时再次new就是按照四步走，给返回的对象绑定了a属性值时10，所以输出10。 用尽可能少的代码实现字符串str 重复n次。123function (str,n)&#123; return (new Array(n+1).join(str));&#125; 解析：利用的就是new Array(5)就是创建一个5项的空数组，此时join.(“☆”)，得到”☆☆☆☆”。所以要加1。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"观察者模式+原型链方法实现的一个小案例","slug":"观察者模式+原型链方法实现的一个小案例","date":"2017-09-07T16:01:49.996Z","updated":"2017-09-07T16:02:44.228Z","comments":true,"path":"2017/09/08/观察者模式+原型链方法实现的一个小案例/","link":"","permalink":"http://yoursite.com/2017/09/08/观察者模式+原型链方法实现的一个小案例/","excerpt":"","text":"题目描述如下：用JavaScript编写两个类，Restaurant餐馆类和Customer顾客类，要求是：餐馆类的实例拥有name餐厅名字属性和cook做饭方法，cook方法接受一个菜名字符串做参数，弹出“xxx餐厅正在为你做xxx菜”。顾客类的实例拥有enter进入餐厅的方法，接受一个餐厅实例做参数；还拥有order点菜方法，接受一个菜名字符串做参数，可以调用该餐厅的cook方法，会弹出相应信息。 下面是实现的代码，在题目要求的基础上利用昨天学到的观察者模式添加了一个小功能，即当餐馆打烊的时候，所有在餐馆的顾客都要离开。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//餐馆类function Restaurant(name) &#123; this.name = name; this.customer = [];&#125;;Restaurant.prototype.cook = function (customer,str) &#123; alert(this.name + \"餐厅正在为\"+ customer +\"做\" + str + \"菜\");&#125;Restaurant.prototype.register = function(customer)&#123; this.customer.push(customer)&#125;//餐厅打烊Restaurant.prototype.dayang = function()&#123; for(var i = 0;i&lt;this.customer.length;i++)&#123; alert(this.customer[i].name + \"走了\"); &#125;&#125;//顾客function Customer(name) &#123; this.name = name; this.restaurant = null;&#125;Customer.prototype.enter = function (restaurant) &#123; //纪录自己进入的餐厅 this.restaurant = restaurant; this.restaurant.register(this);&#125;Customer.prototype.order = function (str) &#123; //调用自己进入的餐厅的cook方法 this.restaurant.cook(this.name, str)&#125;//实例化餐厅var maidanglao = new Restaurant(\"麦当劳\");var kfc = new Restaurant(\"肯德基\");var qingfegnboazipu = new Restaurant(\"庆丰包子铺\")var xiaoming = new Customer(\"小明\");xiaoming.enter(kfc);xiaoming.order(\"鸡腿汉堡\")var xiaogang = new Customer(\"小刚\");xiaogang.enter(kfc);xiaogang.order(\"可乐\")var xiaohong = new Customer(\"小红\");xiaohong.enter(qingfegnboazipu);xiaohong.order(\"炒肝\");kfc.dayang();qingfengbaozipu.dayang(); 解析：这道题的难点在于餐厅拥有的cook方法，并不是餐厅在调用，而是用户的order在调用。用户的enter方法，要纪录下来自己进入哪家餐厅，当用户order的时候，就调用自己进入的这家餐厅的cook方法。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"面试题，设计模式","slug":"面试题，设计模式","permalink":"http://yoursite.com/tags/面试题，设计模式/"}]},{"title":"关于原型链的一道面试题的思考","slug":"关于原型链的一道面试题的思考","date":"2017-09-07T11:42:29.906Z","updated":"2017-09-07T11:43:15.289Z","comments":true,"path":"2017/09/07/关于原型链的一道面试题的思考/","link":"","permalink":"http://yoursite.com/2017/09/07/关于原型链的一道面试题的思考/","excerpt":"","text":"这道题考了原型链，不好用文字描述，所以就画了一些图来帮助理解 试写出程序运行结果123456789101112function A()&#123;&#125;;function B()&#123; return new A();&#125;A.prototype = B();B.prototype = new B();var a = new A();var b = new B();console.log(a._proto_==b._proto_);console.log(a instanceof A);console.log(a instanceof B);console.log(b instanceof A); 分析： 程序执行到第5行，B()实际上返回一个A的实例，所以A.prototype 指向了一个A的实例，我们暂且称这个A的实例为实例A1。注意，此时A.prototype不再指向原生的A.prototype。但原生的A.prototype还存在，并不会被垃圾回收机制回收，因为它还被实例A1._proto_指向着。示意图如下： 程序执行到第6行，new B()同样返回一个A的实例，我们成为实例A2，此时B.prototype 指向了实例A2，然后实例A2的_proto_指向了谁呢，指向了实例A1！因为在第一步我们已经说过，构造函数A.prototype指向了实例A1。示例图如下： 再看第7行，new A()再次生成一个A的实例，这个实例为a。第8行，再次返回一个A的实例（前面已经说过，new B()其实就是new A()） 。最后的示例图如下： 所以由图3可以看出：console.log(a instanceof A)为true。 要判断最后三条语句，我们要明白instanecof 的判断队则是什么，可以参考王福明的深入理解javascript原型和闭包（5）——instanceof，这里直接给出答案：123console.log(a instanceof A); //true console.log(a instanceof B); //falseconsole.log(b instanceof A); //true","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"DOM0级事件处理和DOM2级事件处理的区别","slug":"DOM0级事件处理和DOM2级事件处理的区别","date":"2017-09-07T07:39:47.668Z","updated":"2017-09-07T07:40:22.600Z","comments":true,"path":"2017/09/07/DOM0级事件处理和DOM2级事件处理的区别/","link":"","permalink":"http://yoursite.com/2017/09/07/DOM0级事件处理和DOM2级事件处理的区别/","excerpt":"","text":"DOM0级分为两个 在标签内写onclick事件 1&lt;input id=\"myButton\" type=\"button\" value=\"Press Me\" onclick=\"alert('thanks');\" &gt; 在JS写onlicke=function（）{ }函数 123document.getElementById(\"myButton\").onclick = function () &#123; alert('thanks');&#125; DOM0级只能添加到冒泡阶段，相同对象的相同事件就覆盖了，如下面的代码最后只弹出B123456box.onclick = function()&#123; alert(\"A\")&#125;box.onclick = function()&#123; alert(\"B\")&#125; DOM2级 只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()。 他们都有三个参数 第一个参数是事件名（如click） 第二个参数是事件处理程序函数 第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用，默认为false DOM2级的特点 addEventListener():可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用 只有2级DOM包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段 123&lt;span&gt; &lt;a&gt;&lt;/a&gt;&lt;/span&gt; 点击a后capturing(捕捉)阶段事件传播会从document-&gt; span-&gt;a，然后发生在a，最后bubbling(冒泡)阶段事件传播会从a-&gt;span-&gt;document 。 最底层的元素就不再区分捕获阶段和事件冒泡阶段 事件不会覆盖，先写的先执行 DOM事件流 为什么没有DOM1级 DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型 最后以一道面试题加深对DOM0级和DOM2级的理解题目：box1包含box2，box2包含box3，以下代码会依次弹出什么：123456789101112131415161718192021222324252627box2.onclick = function()&#123; alert(\"A\")&#125;box2.onclick = function()&#123; alert(\"B\")&#125; box2.addEventListener(\"click\",function()&#123; alert(\"C\")&#125;,false)box2.addEventListener(\"click\",function()&#123; alert(\"D\")&#125;,false)box2.addEventListener(\"click\",function()&#123; alert(\"E\")&#125;,true)box2.addEventListener(\"click\",function()&#123; alert(\"F\")&#125;,true)box3.addEventListener(\"click\",function()&#123; alert(\"G\")&#125;,false)box3.addEventListener(\"click\",function()&#123; alert(\"H\")&#125;)box3.addEventListener(\"click\",function()&#123; alert(\"I\")&#125;) 会依次弹出：E，F，G，H，I，B，C，D。不解释了","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"以原型对象属性方式开发轮播图插件","slug":"以原型对象属性方式开发轮播图插件","date":"2017-09-06T17:06:19.102Z","updated":"2017-09-06T17:08:44.644Z","comments":true,"path":"2017/09/07/以原型对象属性方式开发轮播图插件/","link":"","permalink":"http://yoursite.com/2017/09/07/以原型对象属性方式开发轮播图插件/","excerpt":"","text":"jQuery实现轮播图效果，顺便复习一下原型对象属性的书写模式。可通过new Carousel创建一个轮播图实例。 创建一个carousel.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128(function()&#123; //强行暴露一个变量 window.Carousel = Carousel; function Carousel(JSON)&#123; this.dom = $(\"#\" + JSON.id); //放置轮播图的父容器 this.$imagesUl = null; //放置轮播图的ul this.$imagesUlLis = null; //放置轮播图的li this.$leftBtn = null; //放置轮播图左按钮 this.$rightBtn = null; //放置轮播图右按钮 this.$circleOl = null; //放置轮播的小圆点的ol this.$circleLis = null; //放置轮播的小圆点的li this.pictureLength = JSON.images.length; //图片个数 this.image = JSON.images; //图片地址数组 this.height = JSON.height; //高 this.width = JSON.width; //宽 this.leftBtn = null; //左按钮 this.rightBtn = null; //右按钮 this.index = 0; //当前轮播图的序号 this.animateDuration = JSON.animateDuration; //缓动时间 this.interval = JSON.interval; //间隔时间 this.timer = null; //定时器 this.init(); //初始化 this.bindEvent(); //绑定事件 this.autoPlay() //自动播放 &#125; //初始化 Carousel.prototype.init = function()&#123; //创建dom树 this.$imagesUl = $(\"&lt;ul&gt;&lt;/ul&gt;\"); this.dom.append(this.$imagesUl); for(var i=0 ;i&lt;this.pictureLength;i++)&#123; $(\"&lt;li&gt;&lt;img src='\"+this.image[i]+\"'&gt;&lt;/li&gt;\").appendTo(this.$imagesUl) &#125; this.$imagesUlLis = this.$imagesUl.find(\"li\"); //布局 this.dom.css(&#123; \"height\" : this.height + \"px\", \"width\" : this.width + \"px\", \"position\" : \"relative\", \"overflow\" : \"hidden\" &#125;) this.$imagesUlLis.css(&#123; \"position\" : \"absolute\", \"left\" : this.width + \"px\", \"top\" : 0, \"list-style\" : \"none\" &#125;) this.$imagesUlLis.eq(0).css(\"left\",0) //创建按钮 this.$leftBtn = $(\"&lt;a href='javascript:;' class='leftBtn'&gt;&lt;/a&gt;\"); this.$rightBtn = $(\"&lt;a href='javascript:;' class='rightBtn'&gt;&lt;/a&gt;\"); this.$leftBtn.appendTo(this.dom); this.$rightBtn.appendTo(this.dom); //小圆点 this.$circleOl =$(\"&lt;ol class='circles'&gt;&lt;/ol&gt;\"); this.$circleOl.appendTo(this.dom); for(var i=0 ;i&lt;this.pictureLength;i++)&#123; $(\"&lt;li&gt;&lt;/li&gt;\").appendTo(this.$circleOl); &#125; this.$circleLis = this.$circleOl.find(\"li\"); this.$circleLis.eq(0).addClass(\"current\"); &#125; //绑定事件 Carousel.prototype.bindEvent = function()&#123; var self = this; this.$rightBtn.click(function()&#123; if(self.$imagesUlLis.is(\":animated\"))&#123; return &#125; self.showNext(); &#125;) this.$leftBtn.click(function()&#123; self.showPrev(); &#125;) this.$circleLis.click(function()&#123; self.show($(this).index()) &#125;) this.dom.mouseenter(function()&#123; clearInterval(self.timer) &#125;); this.dom.mouseleave(function()&#123; self.autoPlay() &#125;); &#125; //显示下一个轮播图 Carousel.prototype.showNext = function()&#123; this.$imagesUlLis.eq(this.index).animate(&#123;\"left\":-this.width&#125;,this.animateDuration) this.index ++ ; this.index = this.index&gt;(this.pictureLength-1)?0:this.index; this.$imagesUlLis.eq(this.index).css(\"left\",this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); this.changeCircles() &#125; //显示上一个轮播图 Carousel.prototype.showPrev = function()&#123; this.$imagesUlLis.eq(this.index).animate(&#123;\"left\":this.width&#125;,this.animateDuration) this.index -- ; this.index = this.index &lt; 0 ?this.pictureLength-1:this.index; this.$imagesUlLis.eq(this.index).css(\"left\",-this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); this.changeCircles() &#125; //点击小圆点切换轮播图 Carousel.prototype.show = function(number)&#123; var old = this.index; this.index = number; if(this.index&gt;old)&#123; this.$imagesUlLis.eq(old).animate(&#123;\"left\":-this.width&#125;,this.animateDuration); this.$imagesUlLis.eq(this.index).css(\"left\",this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); &#125;else&#123; this.$imagesUlLis.eq(old).animate(&#123;\"left\":this.width&#125;,this.animateDuration); this.$imagesUlLis.eq(this.index).css(\"left\",-this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); &#125; this.changeCircles() &#125; //点击小圆点的状态随轮播图的切换而切换 Carousel.prototype.changeCircles = function()&#123; this.$circleLis.eq(this.index).addClass(\"current\").siblings().removeClass(); &#125; //自动播放 Carousel.prototype.autoPlay = function()&#123; var self = this; this.timer =setInterval(function()&#123; self.showNext(); &#125;,this.interval); &#125;&#125;)() 在html文件中引进刚才的carsouel.js文件,创建一个轮播图对象，附加上css样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.11.3/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"Carousel.js\"&gt;&lt;/script&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; #lunbo&#123; margin: 100px auto; &#125; .leftBtn&#123; display: block; width: 40px; height: 50px; background-color: red; position: absolute; left: 0; top: 150px; margin-top: -25px; &#125; .rightBtn&#123; display: block; width: 40px; height: 50px; background-color: red; position: absolute; left: 460px; top: 150px; margin-top: -25px; &#125; .circles&#123; position: absolute; top: 270px; left: 250px; margin-left: -68px; &#125; .circles li&#123; width: 16px; height: 16px; border-radius: 8px; background-color: green; list-style: none; float: left; margin-left: 8px; cursor: pointer; &#125; .circles li.current&#123; background-color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"lunbo\"&gt;&lt;/div&gt; &lt;script&gt; //创建轮播图实例 var c = new Carousel(&#123; \"id\" : \"lunbo\", \"images\":[ \"img/0.png\", \"img/1.png\", \"img/2.png\", \"img/3.png\", \"img/4.png\", \"img/5.png\", ], \"height\" : 300, \"width\" : 500, \"animateDuration\" : 500, \"interval\" : 3000 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"React中ES6方法创建组件的this","slug":"React中ES6方法创建组件的this","date":"2017-09-04T02:26:14.629Z","updated":"2017-09-04T02:25:27.398Z","comments":true,"path":"2017/09/04/React中ES6方法创建组件的this/","link":"","permalink":"http://yoursite.com/2017/09/04/React中ES6方法创建组件的this/","excerpt":"","text":"学习React的时候，一直为this所困扰，今天就来好好的整理一下，先看一个官方的demo : 12345678910111213141516171819202122232425class LikeButton extends React.Component &#123; constructor() &#123; super(); this.state = &#123; liked: false &#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125; render() &#123; const text = this.state.liked ? 'liked' : 'haven\\'t liked'; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); 重点看第8行和第16行，在 class LikeButton extends React.Component 中我们是声明该class，因为this具体是由其上下文决定的，因此在类定义中我们无法得知this用法。 相当于是new了上面定义的类，首先调用 constructor() 函数， this.state 的this上下文就是该实例对象；同理，render() 函数中 this.state.liked 的this上下文也是该对象。问题在于 onClick={this.handleClick} ，获取该函数引用是没有问题，这里的this上下文就是该对象。 这时问题来了，在原来 React.createClass 中， handleClick() 在onClick事件触发的时候，会自动绑定到LikeButton实例上，这时候该函数的this的上下文就是该实例。不过在ES6的class的写法中，Facebook取消了自动绑定，实例化LikeButton后，handleClick()的上下文是div的支撑实例（ backing instance ），而 handleClick() 原本要绑定的上下文是LikeButton的实例。因此要用到第8行的使用bind()函数改变this的上下文## 使用bind()函数改变this的上下文 总结起来就是：ES6方法创造的React组件并不自动为我们绑定this到当前的实例对象，第8行代码的作用就是通过bind方法让当前的实例中handleClick函数被调用时，this始终是指向当前组件实例。 对于出现的这个问题，我们有两种解决方法 使用bind()函数改变this的上下文 可以在class声明中的constructor()函数中，使用this.handleClick = this.handleClick.bind(this)也就是我们开头提到的方法 除此我们也可以在具体使用该函数的地方绑定this的上下文到LikeButton实例对象，代码如下 123&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; You &#123;text&#125; this. Click to toggle.&lt;/div&gt; 这种方法需要我们每次使用bind()函数绑定到组件对象上。 es6的箭头函数es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用如下代码： 123&lt;div onClick=&#123;() =&gt; this.handleClick()&#125;&gt; You &#123;text&#125; this. Click to toggle.&lt;/div&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"React","slug":"前端开发/React","permalink":"http://yoursite.com/categories/前端开发/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Hexo主题--Human初体验","slug":"Hueman","date":"2017-08-12T08:40:16.027Z","updated":"2017-08-12T08:45:32.099Z","comments":true,"path":"2017/08/12/Hueman/","link":"","permalink":"http://yoursite.com/2017/08/12/Hueman/","excerpt":"","text":"之前折腾过hexo的主题next，相信用hexo搭博客的，很多人都选用next，但在使用的过程中，总感觉next缺少了点什么，之后博客搭起来后，除了前期写了几篇文章，就把它晾在一边，昨晚在简书上搜文章时，发现一个小姐姐的博客搭的挺漂亮的，又给出了详细的搭建过程，于是今天早上一早就起来按照教程，把hexo博客的next主题给换成了hueman主题。 小姐姐的博客在这里 》传送门，还有很多前端干货哦。 更换主题Hueman主题首页 进入hexo的根目录，打开git bash，克隆Hueman到themes文件夹 1$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 修改hexo根目录下的_config.yml文件 1theme: hueman 重命名theme》hueman文件目录下的_config.yml.example为_config.yml (可选项），安装此插件，这样博客可以支持搜索功能，在hexo的根目录下 1$ npm install -S hexo-generator-json-content 最后在hexo根目录执行以下命令就可以把更改部署上GitHub服务器了 123$ hexo clean$ hexo generate$ hexo deploy 配置主题主要是修改头像，网站的favicon，添加评论系统，小姐姐的博客说的很清楚了，这里就不再介绍了，遇到问题也可以到主题的GitHub的issue上给作者留言，很快就可以得到回复的，或者在issue看大家的提问和作者的解答。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"Human","slug":"Human","permalink":"http://yoursite.com/tags/Human/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"用QGIS将shp转json","slug":"用QGIS将shp转json","date":"2017-05-21T14:47:16.000Z","updated":"2017-09-04T06:30:15.843Z","comments":true,"path":"2017/05/21/用QGIS将shp转json/","link":"","permalink":"http://yoursite.com/2017/05/21/用QGIS将shp转json/","excerpt":"","text":"下载 QGIS，QGIS 为开源免费软件，不用破解，安装比较容易，这里就不再列出详细教程。 打开 QGIS Destktop。 添加 vector file，如图箭头所示。更快捷的方法是将 ，将 shp 、dbf 等文件直接拖到 Layers Panel 框里面 。这样就可以跳过步骤 4 直接打开文件了。 弹出选择文件的对话框，Encoding 选择 System，然后点击 Browse，选择 shp 及相关的文件添加进来。（最重要的是 shp 格式的文件和 dbf 格式的文件）。其中步骤 2 点击后如下图所示 打开文件后，点击属性表看一下中文是否乱码打开后的属性表如图所示，没有乱码，如果乱码，一般是因为步骤 4的 Encoding 选项那里选错了。 导出 geojson 文件：在左边的 Layers panel 区域，在任意一个图层右键，选择 Save As。弹出保存文件的对话框，顶部的 Format 选择 geojson，然后点击browse，选择保存文件的路径。点击确定保存。这样就可以把shp转为json了。导出完成后，全选 Layers panel 里面打开的图层文件，右键→remove，即可关闭所打开的图层。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"shp","slug":"shp","permalink":"http://yoursite.com/tags/shp/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"使用gulp编译less","slug":"使用gulp编译less","date":"2017-03-16T17:36:11.796Z","updated":"2017-09-04T02:46:07.498Z","comments":true,"path":"2017/03/17/使用gulp编译less/","link":"","permalink":"http://yoursite.com/2017/03/17/使用gulp编译less/","excerpt":"","text":"学习前端，有时候配置环境，真的是一把辛酸一把泪，虽然网上不乏各式各样详细的教程，但是总有那么一点点的瑕疵，或者是因为自己有些地方理解不了，结果就往往卡在一个地方一筹莫展。 今天的收获 通过慕课网的学习了解了less的作用和编写 安装和配置gulp 使用gulp编译less参考资料 less 即学即用 gulp详细入门教程 gulp新手入门教程 node.js使用gulp编译less 主要步骤1. 安装最新版本的Node.js 新版本的Node.js已集成npm node.js安装-菜鸟教程 2. 全局安装gulp 桌面直接打开Windows的命令行安装，代码如下 1npm install gulp -g 3. 创建gulp项目和局部安装gulp 局部安装与全局安装不同，局部安装需要进入你所需要的前端project的文件夹里面。所以在局部安装之前，需要先在合适的盘建立一个工程文件夹，比如我在E盘的MyCode文件夹里面的ife.baidu文件夹建立了一个task1-9的文件夹，在这个文件夹里面有新建了一个HTML文件，style文件夹，less文件夹等 用Windows的命令行先进入task1-9文件夹 创建gulp项目（就是进入文件夹后再用命令行） 1npm init 然后会出现一大段的文字，提示你输入一些信息，网上找的图：然后就会发现task-1-9文件下多了一个package.json文件。 局部安装gulp（注意同样在文件夹在输入命令行） 1$ npm install gulp --save-dev 然后你的task-1-9文件夹又多了一个node_modules文件夹，里面有好多文件。 4. 本地安装gulp插件（以less插件为例）（文件夹内执行）1npm install gulp-less --save-dev 全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能 5. 新建和编辑gulpfile.js文件 在文件夹下新建一个gulpfile.js文件 然后按照以下说明编写gulpfile.js文件 1234567891011121314151617181920212223242526// 获取 gulpvar gulp = require(&apos;gulp&apos;);// 获取 gulp-less 模块var less = require(&apos;gulp-less&apos;);// 编译less// 在命令行输入 gulp less 启动此任务gulp.task(&apos;less&apos;, function () &#123; // 1. 找到 less 文件，需提前项目文件夹里面新建一个less文件 //再在less文件夹里新建一个less文件，文件的名字可自定义，具体看下图的我的文件结构 gulp.src(&apos;less/*.less&apos;) // 2. 编译为css .pipe(less()) // 3. 另存文件，同理需要在项目文件夹中新建一个style的文件。 .pipe(gulp.dest(&apos;style/css&apos;));&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task(&apos;auto&apos;, function () &#123; // 监听文件修改，当文件被修改则执行 less 任务 gulp.watch(&apos;less/**.less&apos;, [&apos;less&apos;]);&#125;);// 使用 gulp.task(&apos;default&apos;) 定义默认任务// 在命令行使用 gulp 启动 less 任务和 auto 任务gulp.task(&apos;default&apos;, [&apos;less&apos;, &apos;auto&apos;]); 其中的index.css文件是步骤6才生成的。 6. 运行gulp 在项目文件夹中打开命令行，如第5点的代码显示，直接执行以下命令即可,因为default已经包含了less方法和auto方法。 1gulp default 当然也可以分别来执行 12gulp lessgulp auto 运行的结果就是，你可以一边编写less文件，一般自动生成 CSS文件了，赶紧去试一试吧。 补充 gulp中文API 编译less只是gulp功能的一小部分，还有很多功能需要去学习。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"从零开始用Hexo+Github搭建博客","slug":"我的第一篇博客-从零开始用Hexo+Github搭建博客","date":"2017-03-09T17:29:23.609Z","updated":"2017-09-04T02:44:38.656Z","comments":true,"path":"2017/03/10/我的第一篇博客-从零开始用Hexo+Github搭建博客/","link":"","permalink":"http://yoursite.com/2017/03/10/我的第一篇博客-从零开始用Hexo+Github搭建博客/","excerpt":"","text":"昨晚用有道云笔记写Markdown文档的时候，发现Markdown不能插入本地图片，师姐说可以在七牛申请一个服务器，然而又发现申请服务器需要一个域名，于是又去请教师姐，然后师姐说我们可以用GitHub免费搭建一个博客，不需要购买，这两天你们在学习GitHub和Git的操作，那明天的任务就把博客搭出来吧，用Hexo和GitHub…… 写在前面 本教程主要是收集和总结了用Hexo和Github搭建博客过程中所参考的资料，踩过的坑，以及一些注意的事项，并没有详细的写出每一次操作。 主要参考教程 手把手教你用Hexo+GitHub搭建属于自己的博客 使用hexo+github搭建免费个人博客详细教程 在Github上面搭建Hexo博客（一）：部署到Github 基本过程 搭建环境（Node.js和git的安装和配置,GitHub账号设置） 安装Hexo和配置Hexo 将Hexo与GitHub page关联起来 选择主题 主题设置 编写Markdown 1. 搭建环境1.1 Node.js的安装和配置 Node.js安装配置 安装过程中除了修改安装路径外，其他的保持默认设置即可。 安装完成后，检查一下是否安装成功，同时按下Win和R键，打开运行窗口，输入cmd，回车打开命令行界面，输入 12node -vnpm -v 如果出现node和npm的版本号，则表示安装成功了 之前失败过一次，后来卸载了重装就成功了哈哈1.2 Git的安装和配置 Git安装 Git教程1.3 GitHub账号设置 申请GitHub账号 创建GitHub仓库（这个仓库和平时的GitHub仓库不同，命名的格式是gourname.github.io，如我的github的全名为xiaoxiongzi，那仓库的命名就为xiaoxiongzi.github.io） ==重点难点：将本地仓库和远程仓库关联起来== 2. 安装Hexo和配置Hexo 可以参考教程手把手教你用Hexo+GitHub搭建属于自己的博客 Hexo的相关配置 初始Hexo 1hexo init 安装npm组件 1npm install 体验Hexo 1hexo g 1hexo s 出现相关提示，在浏览器中打开就可以了。 3. 将Hexo与GitHub page 联系起来1. 配置Deployment，将本地的文件部署（上传）到Github账户中 编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码（在你修改时，把 xiaoxiongzi要替换成你自己的用户名） 1234deploy: type: git repository: http://github.com/xiaoxiongzi/xiaoxiongzi.github.io.git branch: master .yml文件对格式规范要求很严格，type: repository: branch: 前面有两个空格，冒号后面都有一个空格。 执行以下指令即可完成部署（如果提示错误，可以看下面注意）：12$ hexo generate$ hexo deploy 2.配置SSH 具体可以参考在Github上面搭建Hexo博客（一）：部署到Github的配置SSH部分。 4. 使用Hexo写博客 Hexo官网 主题推荐NexT 具体过程请参考使用hexo+github搭建免费个人博客详细教程","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]}]}