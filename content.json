{"meta":{"title":"小雄子的博客","subtitle":"编程的点点滴滴","description":"每多学一点知识，就能少写一点代码","author":null,"url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-05-21T17:53:57.000Z","updated":"2017-05-21T18:08:54.142Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2017-05-21T17:54:40.000Z","updated":"2017-05-21T17:56:56.362Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-21T17:31:57.000Z","updated":"2017-05-21T18:08:40.286Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript高程复习(第3章到第6章)","slug":"JavaScript高程复习（第3章到第6章）","date":"2017-09-11T13:14:56.097Z","updated":"2017-09-11T13:57:18.657Z","comments":true,"path":"2017/09/11/JavaScript高程复习（第3章到第6章）/","link":"","permalink":"http://yoursite.com/2017/09/11/JavaScript高程复习（第3章到第6章）/","excerpt":"","text":"第三章 基本概念3.1 语法 ECMAScript标识符一般采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写 3.3 变量 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。 3.4 数据结构 ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number、String。还有一个种复杂数据类型–Object typeof 操作符的返回值 “function” —— 如果这个值是函数。从技术角度讲，函数在 ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。 “object” ——如果这个值是对象或 null，因为null被认为是一个空对象的引用 Chrome 7 及之前版本对正则表达式应用 typeof 会返回 “function” 。在IE 和 Firefox中，对正则表达式应用 typeof 会返回 “object” typeof 是一个操作符而不是函数，所以后面不必加括号如typeof（） 3.4.2 Undefine类型 对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值 3.4.3 Null类型如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用 1alert(null == undefined) //true 3.4.5 Number类型 要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean() 永远不要测试某个特定的浮点数值。 任何竖直除以非数值会返回NaN，因此不会影响其他代码的执行。 数值转换 Number（） 如果是 undefined ，返回 NaN 如果是 null 值，返回 0 如果字符串中包含有效的十六进制格式，例如 “0xf” ，则将其转换为相同大小的十进制整数 如果字符串是空的（不包含任何字符），则将其转换为 0，而parseInt（）则返回NaN 1234var num1 = Number(\"Hello world!\"); //NaNvar num2 = Number(\"\"); //0var num3 = Number(\"000011\"); //11var num4 = Number(true); //1 ParseInt（）parseInt() 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()就会返回 NaN ；也就是说，用 parseInt() 转换空字符串会返回 NaN （ Number() 对空字符返回 0）。如果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符 1234567var num1 = parseInt(\"1234blue\"); // 1234var num2 = parseInt(\"\"); // NaNvar num3 = parseInt(\"0xA\"); // 10（十六进制数）var num4 = parseInt(22.5); // 22var num5 = parseInt(\"070\"); // 56（八进制数）var num6 = parseInt(\"70\"); // 70（十进制数）var num7 = parseInt(\"0xf\"); // 15（十六进制数） 为了消除在使用 parseInt() 函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制） 1var num = parseInt(\"0xAF\", 16); //175 实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的 “0x” 。 parseFloat（） 1234567var num1 = parseFloat(\"1234blue\"); //1234 （整数）var num2 = parseFloat(\"0xA\"); /*0,与parseInt不同，parseFlort会始终忽略前导零，而parseInt会将前导零解析为八进制*/var num3 = parseFloat(\"22.5\"); //22.5var num4 = parseFloat(\"22.34.5\"); //22.34var num5 = parseFloat(\"0908.5\"); //908.5var num6 = parseFloat(\"3.125e7\"); //31250000 3.4.6 String类型 toString()和String()方法的不同 null和undefined没有toString()方法，在不知道要转换的值是不是 null 或 undefined 的情况下，可以使用转型函数 String()。 在调用数值的 toString() 方法时，可以传递一个参数：输出数值的基数。默认情况下， toString() 方法以十进制格式返回数值的字符串表示。而通过传递基数， toString() 可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值 123456var num = 10;alert(num.toString()); // \"10\"alert(num.toString(2)); // \"1010\"alert(num.toString(8)); // \"12\"alert(num.toString(10)); // \"10\"alert(num.toString(16)); // \"a\" 12345678var value1 = 10;var value2 = true;var value3 = null;var value4;alert(String(value1)); // \"10\"alert(String(value2)); // \"true\"alert(String(value3)); // \"null\"alert(String(value4)); // \"undefined\" 3.4.7 Object类型Object 的每个实例都具有下列属性和方法 constructor ：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object() 。 hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty(“name”) ）。 isPrototypeOf(object) ：用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句，与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。 toString() ：返回对象的字符串表示 valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同 3.5 操作符 一元加减操作符 一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响,不过，在对非数值应用一元加操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换。 按位异或 ^ 左移 &lt;&lt; 有符号右移 &gt;&gt; 无符号右移 &gt;&gt;&gt; 逻辑非! 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反 逻辑与&amp;&amp;(短路操作) 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象 如果有一个操作数是 null ，则返回 null 如果有一个操作数是 NaN ，则返回 NaN 如果有一个操作数是 undefined ，则返回 undefined 即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false ，则无论第二个操作数是什么值，结果都不再可能是true 逻辑或|| 逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true ，就不会对第二个操作数求值了 我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值 1var myObject = preferredObject || backupObject; 减法 如果有一个操作数是字符串、布尔值、 null 或 undefined ，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN 123456var result1 = 5 - true; // 4，因为 true 被转换成了 1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - \"\"; // 5，因为\"\" 被转换成了 0var result5 = 5 - \"2\"; // 3，因为\"2\"被转换成了 2var result6 = 5 - null; // 5，因为 null 被转换成了 0 第四章 变量、作用域和内存问题4.1 基本类型和引用类型的值 ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量 1234var obj1 = new Object();var obj2 = obj1;obj1.name = \"Nicholas\";alert(obj2.name); //\"Nicholas\" 参数只能按值传递，不管是基本类型的值还是引用类型的值12345678function setName(obj) &#123; obj.name = \"Nicholas\"; obj = new Object(); obj.name = \"Greg\";&#125;var person = new Object();setName(person);alert(person.name); //\"Nicholas\" 实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 检测类型 instanceof虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为ECMAScript提供了 instanceof 操作符 123alert(person instanceof Object); // 变量 person 是 Object 吗？alert(colors instanceof Array); // 变量 colors 是 Array 吗？alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？ 第5章 引用类型5.1 Object类型 创建Object类型的两种方法 使用new操作符后跟Object构造函数 对象字面量对象字面量也是向函数传递大量可选参数的首选方式 1234567891011121314151617function displayInfo(args) &#123; var output = \"\"; if (typeof args.name == \"string\")&#123; output += \"Name: \" + args.name + \"\\n\"; &#125; if (typeof args.age == \"number\") &#123; output += \"Age: \" + args.age + \"\\n\"; &#125; alert(output);&#125;displayInfo(&#123; name: \"Nicholas\", age: 29&#125;);displayInfo(&#123; name: \"Greg\"&#125;); 访问对象属性的两种方法 点表示法，最通用 方括号表示法属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法 1person[\"first name\"] = \"Nicholas\" 5.2 Array类型 数组的length属性可读可写的。 123var colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含 3 个字符串的数组colors[colors.length] = \"black\"; // （在位置 3 ）添加一种颜色colors[colors.length] = \"brown\"; // （在位置 4 ）再添加一种颜色 检测数组 instanceof Array.isArray（） 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray('foobar'); // falseArray.isArray(undefined); // false 转换方法 toString() 1234var colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,greenalert(colors.valueOf()); // red,blue,greenalert(colors); // red,blue,green 由于alert() 要接收字符串参数，所以它会在后台调用 toString() 方法，由此会得到与直接调用 toString() 方法相同的结果 join() 123var colors = [\"red\", \"green\", \"blue\"];alert(colors.join(\",\")); //red,green,bluealert(colors.join(\"||\")); //red||green||blue 栈方法:后进先出 push() 返回的是数组的新长度 123var colors = new Array(); // 创建一个数组var count = colors.push(\"red\", \"green\"); // 推入两项alert(count); //2 pop() 返回的是移除的项 123456var colors = [\"red\", \"blue\"];colors.push(\"brown\"); // 添加另一项colors[3] = \"black\"; // 添加一项alert(colors.length); // 4var item = colors.pop(); // 取得最后一项alert(item); //\"black\" 队列方法：先进先出 shift() 移除数组中的第一个项并返回该项 unshift() 在数组前端添加任意个项并返回新数组的长度 重排序方法 reverse() 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //5,4,3,2,1 sort() 12345678910111213//正确的排序方法function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); //0,1,5,10,15 操作方法 concat() 拼接数组 slice() slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。 123var colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];var colors2 = colors.slice(1); //[\"green\", \"blue\", \"yellow\", \"purple\"]var colors3 = colors.slice(1,4); //[\"green\", \"blue\", \"yellow\"] splice() 最强大的数组方法，可删除，插入，替换 删除可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2) 会删除数组中的前两项 插入可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”) 会从当前数组的位置 2 开始插入字符串 “red” 和 “green” 替换可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red” 和 “green” 12345678910var colors = [\"red\", \"green\", \"blue\"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, \"yellow\", \"orange\"); // 从位置 1 开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, \"red\", \"purple\"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 位置方法 indexOf()和lastIndexOf() 这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， indexOf() 方法从数组的开头（位置 0）开始向后查找， lastIndexOf() 方法则从数组的末尾开始向前查找,这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。 12345678910111213141516171819var numbers = [1,2,3,4,5,6,5,2,7];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(5)); //6alert(numbers.lastIndexOf(7)); //8alert(numbers.indexOf(4, 4)); //-1alert(numbers.indexOf(4, 3)); //3alert(numbers.lastIndexOf(2, 8)); //-1alert(numbers.lastIndexOf(2, 5)); //8var person = &#123; name: \"Nicholas\" &#125;;var people = [&#123; name: \"Nicholas\" &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 reduce()和reduceRight()reduce() 和 reduceRight() 的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123;return prev + cur;&#125;);alert(sum); //15 5.4 Date类型 参考MDN-Date类型 5.5 RegExp类型 可以使用RegExp()构造函数来创建RegExp对象，但更多时候正则表达式直接量定义为包含在一队斜杠（/）之间的字符，例如 12var pattern=/s$/var pattern=new RegExp('s$') RegExp实例方法 test() 基本语法：RegExpObject.test(str) param(参数) str是需要检测的字符串 return (返回值) 如果字符串str中含有与RegExpObject匹配的文本的话，返回true，否则返回false 123456var str = \"longen and yunxi\";console.log(/longen/.test(str)); // trueconsole.log(/longlong/.test(str)); //false// 或者创建RegExp对象模式var regexp = new RegExp(\"longen\");console.log(regexp.test(str)); // true exec() 基本语法：RegExpObject.exec(string) param(参数)：string【必填项】要检索的字符串 return(返回值)：返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null 该返回的数组的第一个元素是与正则表达式相匹配的文本，该方法还返回2个属性，index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string；该方法如果不是全局的话，返回的数组与match()方法返回的数组是相同的 123456var str = \"longen and yunxi\";console.log(/longen/.exec(str));// 打印 [\"longen\", index: 0, input: \"longen and yunxi\"]// 假如没有找到的话，则返回nullconsole.log(/wo/.exec(str)); // null 12345678var text = \"mom and dad and baby\";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);alert(matches.index); // 0alert(matches.input); // \"mom and dad and baby\"alert(matches[0]); // \"mom and dad and baby\"alert(matches[1]); // \" and dad and baby\"alert(matches[2]); // \" and baby\" 上面一段代码，为什么matches[1]会是”and dad and baby”，后来参考了使用js中的exec()方法构造正则表达式验证这一篇博客，才知道，“在返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）”这句话中的“捕获组匹配的字符串”是指模式汇总每一个（）所定义的分组所匹配的字符，这也就不难解释为什么matches[1]是”and dad and baby”，matches[2]是“and baby”了。关于index和lastINdex,可参考这篇segmentfault上的问答：js中，exec()方法，为何这里的index是5？,摘抄如下： 12345678910var pattern2 = /.at/g;var matches = pattern2.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern2.lastIndex); //3matches = pattern2.exec(text);alert(matches.index); //5alert(matches[0]); //batalert(pattern2.lastIndex); //8 咱们按逗号之后不加空格来说：你看，第一次检索出来的是cat，第一个字符的索引是0，所以result.index是0，而此时一个检查字符串中每个字符的指针ptr已经走到t后面了，所以lastIndex是3，就是相当于告诉正则表达式，我们已经检查到索引为3的地方了，下一次直接从这里开始就好了。第二次检索从lastIndex也就是3开始，找到后面的bat之后，匹配成功，bat里第一个字符b是4，所以result.index是4，而我们匹配完整个bat的时候，指针ptr已经走到bat后面了，也就是索引为7的位置，所以结果是4和7。这样你再开始下一次检索的时候，就会从text[7]开始，也就是第二个逗号的位置开始往后找，所以下一次匹配是8, sat, 11，再下次12, fat, 15。现在到头了，再匹配一次的话就是null了，这时候你看看pattern1.lastIndex，已经回到0了。 5.5 Function类型 函数是对象，每个函数都是Function类型的实例，函数名是一个指向函数对象的指针。 使用不带圆括号的函数名是访问函数指针，而非调用函数 函数声明与函数表达式的区别 12345678910//函数声明提升，函数正常运行，没有报错alert(sum(10,10));function sum(num1, num2)&#123; return num1 + num2;&#125;//报错alert(sum(10,10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; apply()方法和call()call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f(),可以这样使用call()和apply()。 123456f.call(o);f.apply(o);//每行代码和下面代码的功能类似o.m=f; //将f存储为o的临时方法o.m(); //调用它，不传入参数delete o.m; //将临时方法删除 apply() 方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments 对象，call() 方法与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call() 方法时，传递给函数的参数必须逐个列举出来 一般用来扩充函数赖以运行的作用域 123456789window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor()&#123;alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue bind()方法这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值1234567window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 5.6 基本包装类型 为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型： Boolean 、 Number 和String 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 12var s1 = \"some text\";var s2 = s1.substring(2); 处理过程如下： 创建 String 类型的一个实例 在实例上调用指定的方法 销毁这个实例可以将以上三个步骤想象成是执行了下列 ECMAScript 代码 123var s1 = new String(\"some text\");var s2 = s1.substring(2);s1 = null; 引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看下面的例子： 123var s1 = &quot;some text&quot;;s1.color = &quot;red&quot;; //第二行创建的 String 对象在执行第三行代码时已经被销毁了alert(s1.color); //undefined 5.6.1 Boolean类型 由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof操作符测试 Boolean 对象会返回 true ，而测试基本类型的布尔值则返回 false 理解基本类型的布尔值与 Boolean 对象之间的区别非常重要——当然，我们的建议是永远不要使用 Boolean 对象 5.6.2 Number类型123456var num = 10;alert(num.toString()); //\"10\"alert(num.toString(2)); //\"1010\"alert(num.toString(8)); //\"12\"alert(num.toString(10)); //\"10\"alert(num.toString(16)); //\"a\" Number 类型还提供了一些用于将数值格式化为字符串的方法 toFixed()会按照指定的小数位返回数值的字符串表示 12var num = 10;alert(num.toFixed(2)); //\"10.00\" toExponential()方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式 12var num = 10;alert(num.toExponential(1)); //\"1.0e+1\" 3.toPrecision()对于一个数值来说， toPrecision() 方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分） 1234var num = 99;alert(num.toPrecision(1)); //\"1e+2\"alert(num.toPrecision(2)); //\"99\"alert(num.toPrecision(3)); //\"99.0\" 5.6.3 String类型String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符 12var stringValue = &quot;hello world&quot;;alert(stringValue.length); //&quot;11&quot; 字符方法 charAt()charAt() 方法以单字符字符串的形式返回给定位置的那个字符 12var stringValue = \"hello world\";alert(stringValue.charAt(1)); //\"e\" charCodeAt()想得到的不是字符而是字符编码 12var stringValue = \"hello world\";alert(stringValue.charCodeAt(1)) //\"101\" 字符串操作方法这些方法都不会修改字符串本身的值，它们只是返回一个基本类型的字符串值 concat()用于将一或多个字符串拼接起来，返回拼接得到的新字符串,在实践中一般使用加号操作符来代替 slice(),substring(),substr()的区别首先，他们都接收两个参数，slice和substring接收的是起始位置和结束位置(不包括结束位置)，而substr接收的则是起始位置和所要返回的字符串长度 1234var test='hello world'alert(test.slice(4,7)) //\"o w\"alert(test.substring(4,7)) //\"o w\"alert(test.substr(4,7)) //\"o world\" substring是以两个参数中较小一个作为起始位置，较大的参数作为结束位置 1alert(test.substring(7,4)); //o w 接着，当接收的参数是负数时，slice会将它字符串的长度与对应的负数相加，结果作为参数；substr则仅仅是将负的第一个参数与字符串长度相加后的结果作为第一个参数，而将负的第二个参数转换为0；substring则干脆将负参数都直接转换为0 12345678910var test=\"hello world\"alert(test.slice(-3)) //rldalert(test.substring(-3)) //Hello worldalert(test.substr(-3)) //rldalert(test.slice(3,-4)) //lo walert(test.substring(3,-4)) /*hel 第二点说到，substring会将较小的数作为开始位置，将较大的数作为结束位置。*/alert(test.substr(3,-4)) /*由于第一个参数不是负数，不转换，依然是3，但第二个参数是负数，所以转换为0，所以结果是一个空字符串*/ 字符串位置方法 indexOf()和lastIndexOf()参考数组的indexOf()和lastIndexOf() 123var stringValue = \"hello world\";alert(stringValue.indexOf(\"o\", 6)); //7alert(stringValue.lastIndexOf(\"o\", 6)); //4 trim()方法这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果 1234var stringValue = \" hello world \";var trimmedStringValue = stringValue.trim();alert(stringValue); //\" hello world \"alert(trimmedStringValue); //\"hello world\" 字符串大小写的转换写法 12345var stringValue = \"hello world\";alert(stringValue.toLocaleUpperCase()); //\"HELLO WORLD\"alert(stringValue.toUpperCase()); //\"HELLO WORLD\"alert(stringValue.toLocaleLowerCase()); //\"hello world\"alert(stringValue.toLowerCase()); //\"hello world\" 字符串的匹配模式 match()在字符串上调用match()方法，本质上与调用RegExp的exec()方法相同,match()只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。 12345678var text='cat,bat,sat,fat';var pattern=/.at/;//与pattern.exec(text)相同var matches=text.match(pattern);altert(matches.index); //0altert(matches[0]); //\"cat\"altert(matches.lastIndex); //0 search()这个方法的唯一参数与 match() 方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。 search() 方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回 -1 。而且， search() 方法始终是从字符串开头向后查找模式。 123var text = \"cat, bat, sat, fat\";var pos = text.search(/at/);alert(pos); //1 replace()这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（ g ）标志 12345var text = \"cat, bat, sat, fat\";var result = text.replace(\"at\", \"ond\");alert(result); //\"cond, bat, sat, fat\"result = text.replace(/at/g, \"ond\");alert(result); //\"cond, bond, sond, fond\" split()这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 RegExp 对象（这个方法不会将字符串看成正则表达式）。 split() 方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小 1234var colorText = \"red,blue,green,yellow\";var colors1 = colorText.split(\",\"); //[\"red\", \"blue\", \"green\", \"yellow\"]var colors2 = colorText.split(\",\", 2); //[\"red\", \"blue\"]var colors3 = colorText.split(/[^\\,]+/); //[\"\", \",\", \",\", \",\", \"\"] 5.7 单体内置对象5.7.1 Global对象本书前面介绍过的那些函数，诸如 isNaN() 、 isFinite() 、parseInt() 以及 parseFloat() ，实际上全都是 Global对象的方法。除此之外， Global 对象还包含其他一些方法 URI 编码方法encodeURI() 和 encodeURIComponent() 方法,可以对 URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。 1234567var uri = \"http://www.wrox.com/illegalvalue.htm#start\";//\"http://www.wrox.com/illegal%20value.htm#start\"alert(encodeURI(uri));//\"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start\"alert(encodeURIComponent(uri)); 使用 encodeURI() 编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20 。而 encodeURIComponent() 方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个 URI使用 encodeURI() ，而只能对附加在现有 URI后面的字符串使用 encodeURIComponent()的原因所在。一 般 来 说 ， 我 们 使 用 encodeURIComponent() 方 法 的 时 候 要 比 使 用encodeURI() 更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI进行编码。与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和decodeURIComponent() 。其中， decodeURI() 只能对使用 encodeURI() 替换的字符进行解码。 1234567var uri = \"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start\";//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23startalert(decodeURI(uri));//http://www.wrox.com/illegal value.htm#startalert(decodeURIComponent(uri)); 在第一次调用 decodeURI()输出的结果中，只有 %20 被替换成了空格。而在第二次调用 decodeURIComponent() 输出的结果中，所有特殊字符的编码都被替换成了原来的字符，得到了一个未经转义的字符串。 eval()没什么好说的 5.7.2 Math对象1234var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数； Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数； Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则）。 random() 方法Math.random() 方法返回大于等于 0 小于 1 的一个随机数。如果你想选择一个 1到 10 之间的数值，可以像下面这样编写代码 1var num = Math.floor(Math.random() * 10 + 1); 面向对象的程序设计6.2 创建对象6.2.1 工厂模式用函数来封装以特定接口创建对象的细节 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");var person2 = createPerson(\"Greg\", 27, \"Doctor\"); 优点解决了创建多个相似对象的问题 缺点没有解决对象识别的问题,1alert(person1 instanceof createPerson) //false 6.2.2 构造函数模式12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 构造函数名以大写开头 要创建Person实例，必须使用new 操作符，person1和person2分别保存着Person的一个不同的实例， 这两个对象都有一个 constructor （构造函数）属性，该属性指向 Person12alert(person1.constructor == Person); //truealert(person2.constructor == Person); //true 1234alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person2 instanceof Object); //truealert(person2 instanceof Person); //true 将构造函数当作函数调用 12345678910// 当作构造函数使用var person = new Person(\"Nicholas\", 29, \"Software Engineer\");person.sayName(); //\"Nicholas\"// 作为普通函数调用Person(\"Greg\", 27, \"Doctor\"); // 添加到 windowwindow.sayName(); //\"Greg\"// 在另一个对象的作用域中调用var o = new Object();Person.call(o, \"Kristen\", 25, \"Nurse\");o.sayName(); //\"Kristen\" 存在的问题不同实例上的同名函数是不相等的 1alert(person1.sayName == person2.sayName); //false 可将sayName()函数转移到构造函数的外部1234567891011function Person(name, age, job)&#123;this.name = name;this.age = age;this.job = job;this.sayName = sayName;&#125;function sayName()&#123;alert(this.name);&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 但这又使得全局作用域有点名不其实，只能被某个对象调用，而且如果对象需要定义很多方法，那么就要定义很多个全局函数。 6.2.3 原型模式 isPrototypeOf()如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象（ Person.prototype ），那么这个方法就返回 true 12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //\"Nicholas\" Object.getPrototypeOf()返回[[Prototype]] 的值 12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //\"Nicholas\" hasOwnProperty()可以检测一个属性是存在于实例中，还是存在于原型中 Object.keys()可取得对象上所有课枚举的实例属性，这个方法接受一个对象作为参数 6.2.4 组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。12345678910111213141516171819202122function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends= [\"Shely\",\"Court\"];&#125; Person.prototype = &#123; constructor :Person, sayName : function()&#123; alert(this.name); &#125;&#125; var person1 = new Person(\"Nicholas\",20,\"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Count,Van\"alert(person2.friends); //\"Shelby,Count\"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 6.2.5 动态原型模式1234567891011121314function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; // 方法 if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); 6.2.6 寄生构造函数模式形式上可看作是工厂模式+构造函数模式1234567891011121314//工厂模式function Person(name,age,job)&#123; var o =new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o;&#125;//构造函数模式var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName() //\"Nicholas\" 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式 6.2.7 稳妥构造函数模式稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this ；二是不使用 new 操作符调用构造函数 1234567891011121314function Person(name, age, job)&#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 /*除了使用sayName()方法之外，没有其他办法可以访问name的值*/ o.sayName = function()&#123; alert(name); &#125;; //返回对象 return o;&#125;var friend = Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); //\"Nicholas\" 6.3 继承 构造函数，原型和实例的关系每个构造函数都有一个原型对象prototype，原型对象都包含一个指向构造函数的指针constructor，而实例都包含一个指向原型对象的内容指针proto。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()，valueOf()等默认方法的根本原因。 确定原型与实例的关系 instanceof操作符只要用这个操作符来测试实例与原型链中出现过的构造函数，结果都会返回true。 1altert(instance instanceof Object); //true isPrototypeOf方法只要是原型链中出现过的原型，都可以说是该原型链所派的实例的原型，因此isPrototypeOf()方法也会返回true 1altert(Object.isPrototypeOf(instance)); //true","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript，前端","slug":"JavaScript，前端","permalink":"http://yoursite.com/tags/JavaScript，前端/"}]},{"title":"Canvas开发FlappyBird小游戏","slug":"FlappyBird","date":"2017-09-11T04:55:59.852Z","updated":"2017-09-12T05:14:39.149Z","comments":true,"path":"2017/09/11/FlappyBird/","link":"","permalink":"http://yoursite.com/2017/09/11/FlappyBird/","excerpt":"","text":"原生JavaScript和Canvas实现FlappyBird小游戏 项目地址→传送门 点击这里开始游戏 PS:可以以电脑浏览器的手机模式打开，也可以在手机浏览器中直接打开 游戏运用了Canvas的drawImage，translate，rotate，save，restore，fillRect等API。采用中介者模式，Game类统领全局，负责读取资源，设置定时器，维护各个物体实例，所有的演员都是Game类new 出来的， 游戏项目外部的语句就一条：1var game = new Game(); 其他的所有语句都封装在Game类里面了需要的类： Game类：中介者，读取资源，设置定时器，维护各个物体实例 Bird类：小鸟类，这个类是单例的，实例化一次 Pipe类： 管子类 Land类：大地类 BG类：背景类 sceneManager类：场景管理类 难点 视口的适配 我们的游戏在任何手机上面都是充满视口的这里贴出代码1234567891011121314151617181920212223(function () &#123; var Game = window.Game = function (id) &#123; this.canvas = document.querySelector(id); this.context = this.canvas.getContext('2d'); this.init() &#125; Game.prototype.init = function () &#123; var windowW = document.documentElement.clientWidth; var windowH = document.documentElement.clientHeight; if (windowW &gt; 414) &#123; windowW = 414; &#125; else if (windowW &lt; 320) &#123; windowW = 320; &#125; if (windowH &gt; 736) &#123; windowH = 736 &#125; else if (windowH &lt; 500) &#123; windowH = 500; &#125; this.canvas.width = windowW; this.canvas.height = windowH &#125;&#125;)() 资源管理器 游戏中有多张图片，这些图片都必须先load后，然后才能让定时器开始工作。我们可以自己创建一个资源管理器，主要目的是为了读取外部的配置文件，游戏中的资源管理器R.json文件。存储了游戏中需要的图片对象。游戏所需要的图片在这里下载飞翔的小鸟(Flappy Bird)素材 碰撞检测 因此小鸟的图片其实是一个长方形，而且角度又不断变化导致中心点难于掌握，因此很难判断小鸟与管子的碰撞。这里画了张图帮助自己理解 小鸟下落的速度 需要模拟小鸟的重力，高中物理没有白学 分数的计算 分数的计算与碰撞检测类似，设置一个开关，当管子重新出现时，设置为true。当分值加1时，设置为false。小鸟的最左边的x坐标如果超出了管子的x+width，就认为成功通过。 场景管理器 场景管理器有4个方法enter,update,render，bindEvent。其中定时器在每帧执行update方法和render方法。enter方法由业务来调用，比如用户点击了按钮，此时就进入场景2，鸟撞到了管子，就进入场景3。 这样就把游戏的各个不同阶段分离出来，方便处理。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"JavaScript面向对象笔试汇总(1)","slug":"JavaScript面向对象笔试汇总（1）","date":"2017-09-07T16:10:13.813Z","updated":"2017-09-11T04:57:50.205Z","comments":true,"path":"2017/09/08/JavaScript面向对象笔试汇总（1）/","link":"","permalink":"http://yoursite.com/2017/09/08/JavaScript面向对象笔试汇总（1）/","excerpt":"","text":"程序运行后，输出为何？1234567891011function fun()&#123; var a =1; this.a = 2; function fn()&#123; return this.a; &#125; fn.a = 3; return fn;&#125;var result = fn()();console.log(result); 解析：var a = 1 是一个局部变量，此时fun()是典型的函数直接加圆括号，所以函数的上下文就是window对象。第3行this.a就表示给全局增加了一个a属性，值为2。第一次fun()返回一个内存函数，第二次fun()也是典型的函数直接加圆括号，所以上下文也是window对象。此时运行，返回window.a，因为第一次运行已经给全局设置了a值为2，所以result的结果最终为2。 如何在函数内部得到函数自身的属性1234function f()&#123; //如何在里面获得函数f的属性a&#125;f.a = 100; 做法就是：12345function f()&#123; alert(arguments.callee.a);&#125;f.a = 100;f(); 也可以这样：12345function f()&#123; alert(this.a)&#125;f.a = 100;f.call(f); 考察数组枚举调用函数1234567891011var arr = [fn1,fn2];function fn1()&#123; return this.length;&#125;function fn2() &#123; return this[0]&#125;var a = arr[0]();var b = arr[1]()();console.log(a);console.log(b); 首先看语句arr[0]()，此时是数组枚举出函数，然后调用，所以函数里面的this是数组，也就是this.length要返回的是数组的长度2。第二条语句arr[1]()()表示fn2()运行得到的结果再运行，此时看一下arr[1](),表示的是数组枚举出来然后运行，此时函数里面的this是数组，返回fn1。第二个圆括号就是fn1直接加圆括号运行，this就是window对象，此时window的length属性值为0(测试为0，具体原因不清楚)。因此最终的输出结果使2和0。 程序运行后，输出什么123456789101112131415var a = 1;var obj = &#123; a : 2, fn : (function () &#123; this.a = 3; return function()&#123; return this.a; &#125; &#125;)()&#125;var fn = obj.fn;var result1 = obj.fn();var result2 = fn();console.log(result1);console.log(result2); 解析：首先我们得明白IIFE的执行时机是什么，就是一个对象定义的时候，如果值时表达式，那么在定义的时候，就已经执行掉了，比如下面的程序，先弹出”你好”，再弹出”么么哒”123456var obj = &#123; a : (function()&#123; alert(\"你好\") &#125;)()&#125;alert(\"么么哒\"); 再看我们的题目，程序执行到第5行的IIFE时，this表示window对象，此时全局的a属性就变成了3。第12行，obj.fn() ，this指向obj。此时a为2。第13行，var fn = obj.fn(),再执行fn() ，此时this就是window对象，因此结果为2和3。 给页面上的方形盒子添加onmousemove事件监听，请在图中画出表示event.clientY值的线段并标注1，画出document.documentElement.clientHeight的线段并标注2，画出document.body.scrollTop的线段并标注3： 以下程序会弹出什么 12345678910function fun1()&#123; fun2(arguments)&#125;function fun2(a,b,c,d)&#123; alert(\"a\"); alert(\"b\"); alert(\"c\"); alert(\"d\");&#125;fun1(1,2,3,4) 依次弹出[object Argument]，undefined，undefined，undefined。因为第一行的arguments实际上是一个类数组。要想取得预期的效果，可以这样改：12345678910function fun1()&#123; fun2.apply(null,arguments)&#125;function fun2(a,b,c,d)&#123; alert(\"a\"); alert(\"b\"); alert(\"c\"); alert(\"d\");&#125;fun1(1,2,3,4) apply的妙处就是能打开数组,比如可以用来求数组的最大值12var arr = [2,324,32,536,863,456]Math.max.apply(null,[arr]) 程序运行2000毫秒后，控制台输出什么？12345678910var a = 1；function fun()&#123; var a = 2; this.a = 3;&#125;setTimeout(function()&#123; var a = 4; fun(); console.log(this.a);&#125;,2000) 输出的结果是3，因为第8行执行fun()的时候，this指向的是window，调到第四行改变了a的值，所以this.a为3。 试写出程序执行的结果： 12345678910function fun(fn,arg1,arg2,arg3)&#123; arguments[0](1,2,3)&#125;function fun2(m,n)&#123; alert(this.length); alert(this.callee.length); alert(arguments.length); alert(arguments.callee.length)&#125;fun(fun2); 分别弹出1,4,3,2解析：第一个alert中的this指向arguments类数组的本身，此时arguments的长度为1，就是fun(fun2)的实参fun2。第二个this.callee.length指向的是fun的形参fun(fn,arg1,arg2,arg3)的长度，所以为4。第三个arguments.length是arguments[0](1,2,3)实参的长度，所以为3。第四个arguments.callee.length是fun2(m,n)的形参的长度，所以为2。 试写出程序的执行结果1234567891011121314151617181920var m = 10;var obj1 = &#123; m : 20, fn : (function()&#123; this.m *= 2; m = 5; //注意这里并没有把window的属性m改为5，因为它的下一行有变量声明提升的作用 var m = 6;//，所以第6行改的实际上是闭包里面的m值 return function()&#123; this.m *= m; console.log(this.m); &#125; &#125;)()&#125;;var obj2 = &#123; m : 30&#125;;var fn = obj1.fn;fn();obj.fn();obj.fn.call(obj2); 这道题考了闭包，this的指向，变量声明提升，立即执行函数。输出结果依次为 120 ， 120， 180 。不解释了，看注释 试写出程序执行的结果 1234console.log(Object instanceof Object);console.log(Function instanceof Function);console.log(String instanceof String);console.log(Function instanceof Object); 分析： 任何函数都是Function new出来的。包括Object，Function也是Function new出来的。 a instanceof A ，就要看A的prototype是不是在a 的原型链上。 答案为：true ，true ，false，false，true 试写出程序执行的结果 12345678910function Fun()&#123; this.a = 5; function fun()&#123; this.a = 10; &#125; fun.a = 15; return fun;&#125;var o = new(new Fun());console.log(o.a); 解析：结果为10首先我们要理解new一个函数实例的过程。第一次new Fun()的时候，并且return的是引用类型值，所以函数返回的就是里面的fun函数，此时再次new就是按照四步走，给返回的对象绑定了a属性值时10，所以输出10。 用尽可能少的代码实现字符串str 重复n次。123function (str,n)&#123; return (new Array(n+1).join(str));&#125; 解析：利用的就是new Array(5)就是创建一个5项的空数组，此时join.(“☆”)，得到”☆☆☆☆”。所以要加1。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"观察者模式+原型链方法实现的一个小案例","slug":"观察者模式+原型链方法实现的一个小案例","date":"2017-09-07T16:01:49.996Z","updated":"2017-09-07T16:02:44.228Z","comments":true,"path":"2017/09/08/观察者模式+原型链方法实现的一个小案例/","link":"","permalink":"http://yoursite.com/2017/09/08/观察者模式+原型链方法实现的一个小案例/","excerpt":"","text":"题目描述如下：用JavaScript编写两个类，Restaurant餐馆类和Customer顾客类，要求是：餐馆类的实例拥有name餐厅名字属性和cook做饭方法，cook方法接受一个菜名字符串做参数，弹出“xxx餐厅正在为你做xxx菜”。顾客类的实例拥有enter进入餐厅的方法，接受一个餐厅实例做参数；还拥有order点菜方法，接受一个菜名字符串做参数，可以调用该餐厅的cook方法，会弹出相应信息。 下面是实现的代码，在题目要求的基础上利用昨天学到的观察者模式添加了一个小功能，即当餐馆打烊的时候，所有在餐馆的顾客都要离开。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//餐馆类function Restaurant(name) &#123; this.name = name; this.customer = [];&#125;;Restaurant.prototype.cook = function (customer,str) &#123; alert(this.name + \"餐厅正在为\"+ customer +\"做\" + str + \"菜\");&#125;Restaurant.prototype.register = function(customer)&#123; this.customer.push(customer)&#125;//餐厅打烊Restaurant.prototype.dayang = function()&#123; for(var i = 0;i&lt;this.customer.length;i++)&#123; alert(this.customer[i].name + \"走了\"); &#125;&#125;//顾客function Customer(name) &#123; this.name = name; this.restaurant = null;&#125;Customer.prototype.enter = function (restaurant) &#123; //纪录自己进入的餐厅 this.restaurant = restaurant; this.restaurant.register(this);&#125;Customer.prototype.order = function (str) &#123; //调用自己进入的餐厅的cook方法 this.restaurant.cook(this.name, str)&#125;//实例化餐厅var maidanglao = new Restaurant(\"麦当劳\");var kfc = new Restaurant(\"肯德基\");var qingfegnboazipu = new Restaurant(\"庆丰包子铺\")var xiaoming = new Customer(\"小明\");xiaoming.enter(kfc);xiaoming.order(\"鸡腿汉堡\")var xiaogang = new Customer(\"小刚\");xiaogang.enter(kfc);xiaogang.order(\"可乐\")var xiaohong = new Customer(\"小红\");xiaohong.enter(qingfegnboazipu);xiaohong.order(\"炒肝\");kfc.dayang();qingfengbaozipu.dayang(); 解析：这道题的难点在于餐厅拥有的cook方法，并不是餐厅在调用，而是用户的order在调用。用户的enter方法，要纪录下来自己进入哪家餐厅，当用户order的时候，就调用自己进入的这家餐厅的cook方法。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"面试题，设计模式","slug":"面试题，设计模式","permalink":"http://yoursite.com/tags/面试题，设计模式/"}]},{"title":"关于原型链的一道面试题的思考","slug":"关于原型链的一道面试题的思考","date":"2017-09-07T11:42:29.906Z","updated":"2017-09-07T11:43:15.289Z","comments":true,"path":"2017/09/07/关于原型链的一道面试题的思考/","link":"","permalink":"http://yoursite.com/2017/09/07/关于原型链的一道面试题的思考/","excerpt":"","text":"这道题考了原型链，不好用文字描述，所以就画了一些图来帮助理解 试写出程序运行结果123456789101112function A()&#123;&#125;;function B()&#123; return new A();&#125;A.prototype = B();B.prototype = new B();var a = new A();var b = new B();console.log(a._proto_==b._proto_);console.log(a instanceof A);console.log(a instanceof B);console.log(b instanceof A); 分析： 程序执行到第5行，B()实际上返回一个A的实例，所以A.prototype 指向了一个A的实例，我们暂且称这个A的实例为实例A1。注意，此时A.prototype不再指向原生的A.prototype。但原生的A.prototype还存在，并不会被垃圾回收机制回收，因为它还被实例A1._proto_指向着。示意图如下： 程序执行到第6行，new B()同样返回一个A的实例，我们成为实例A2，此时B.prototype 指向了实例A2，然后实例A2的_proto_指向了谁呢，指向了实例A1！因为在第一步我们已经说过，构造函数A.prototype指向了实例A1。示例图如下： 再看第7行，new A()再次生成一个A的实例，这个实例为a。第8行，再次返回一个A的实例（前面已经说过，new B()其实就是new A()） 。最后的示例图如下： 所以由图3可以看出：console.log(a instanceof A)为true。 要判断最后三条语句，我们要明白instanecof 的判断队则是什么，可以参考王福明的深入理解javascript原型和闭包（5）——instanceof，这里直接给出答案：123console.log(a instanceof A); //true console.log(a instanceof B); //falseconsole.log(b instanceof A); //true","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"DOM0级事件处理和DOM2级事件处理的区别","slug":"DOM0级事件处理和DOM2级事件处理的区别","date":"2017-09-07T07:39:47.668Z","updated":"2017-09-07T07:40:22.600Z","comments":true,"path":"2017/09/07/DOM0级事件处理和DOM2级事件处理的区别/","link":"","permalink":"http://yoursite.com/2017/09/07/DOM0级事件处理和DOM2级事件处理的区别/","excerpt":"","text":"DOM0级分为两个 在标签内写onclick事件 1&lt;input id=\"myButton\" type=\"button\" value=\"Press Me\" onclick=\"alert('thanks');\" &gt; 在JS写onlicke=function（）{ }函数 123document.getElementById(\"myButton\").onclick = function () &#123; alert('thanks');&#125; DOM0级只能添加到冒泡阶段，相同对象的相同事件就覆盖了，如下面的代码最后只弹出B123456box.onclick = function()&#123; alert(\"A\")&#125;box.onclick = function()&#123; alert(\"B\")&#125; DOM2级 只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()。 他们都有三个参数 第一个参数是事件名（如click） 第二个参数是事件处理程序函数 第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用，默认为false DOM2级的特点 addEventListener():可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用 只有2级DOM包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段 123&lt;span&gt; &lt;a&gt;&lt;/a&gt;&lt;/span&gt; 点击a后capturing(捕捉)阶段事件传播会从document-&gt; span-&gt;a，然后发生在a，最后bubbling(冒泡)阶段事件传播会从a-&gt;span-&gt;document 。 最底层的元素就不再区分捕获阶段和事件冒泡阶段 事件不会覆盖，先写的先执行 DOM事件流 为什么没有DOM1级 DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型 最后以一道面试题加深对DOM0级和DOM2级的理解题目：box1包含box2，box2包含box3，以下代码会依次弹出什么：123456789101112131415161718192021222324252627box2.onclick = function()&#123; alert(\"A\")&#125;box2.onclick = function()&#123; alert(\"B\")&#125; box2.addEventListener(\"click\",function()&#123; alert(\"C\")&#125;,false)box2.addEventListener(\"click\",function()&#123; alert(\"D\")&#125;,false)box2.addEventListener(\"click\",function()&#123; alert(\"E\")&#125;,true)box2.addEventListener(\"click\",function()&#123; alert(\"F\")&#125;,true)box3.addEventListener(\"click\",function()&#123; alert(\"G\")&#125;,false)box3.addEventListener(\"click\",function()&#123; alert(\"H\")&#125;)box3.addEventListener(\"click\",function()&#123; alert(\"I\")&#125;) 会依次弹出：E，F，G，H，I，B，C，D。不解释了","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"以原型对象属性方式开发轮播图插件","slug":"以原型对象属性方式开发轮播图插件","date":"2017-09-06T17:06:19.102Z","updated":"2017-09-06T17:08:44.644Z","comments":true,"path":"2017/09/07/以原型对象属性方式开发轮播图插件/","link":"","permalink":"http://yoursite.com/2017/09/07/以原型对象属性方式开发轮播图插件/","excerpt":"","text":"jQuery实现轮播图效果，顺便复习一下原型对象属性的书写模式。可通过new Carousel创建一个轮播图实例。 创建一个carousel.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128(function()&#123; //强行暴露一个变量 window.Carousel = Carousel; function Carousel(JSON)&#123; this.dom = $(\"#\" + JSON.id); //放置轮播图的父容器 this.$imagesUl = null; //放置轮播图的ul this.$imagesUlLis = null; //放置轮播图的li this.$leftBtn = null; //放置轮播图左按钮 this.$rightBtn = null; //放置轮播图右按钮 this.$circleOl = null; //放置轮播的小圆点的ol this.$circleLis = null; //放置轮播的小圆点的li this.pictureLength = JSON.images.length; //图片个数 this.image = JSON.images; //图片地址数组 this.height = JSON.height; //高 this.width = JSON.width; //宽 this.leftBtn = null; //左按钮 this.rightBtn = null; //右按钮 this.index = 0; //当前轮播图的序号 this.animateDuration = JSON.animateDuration; //缓动时间 this.interval = JSON.interval; //间隔时间 this.timer = null; //定时器 this.init(); //初始化 this.bindEvent(); //绑定事件 this.autoPlay() //自动播放 &#125; //初始化 Carousel.prototype.init = function()&#123; //创建dom树 this.$imagesUl = $(\"&lt;ul&gt;&lt;/ul&gt;\"); this.dom.append(this.$imagesUl); for(var i=0 ;i&lt;this.pictureLength;i++)&#123; $(\"&lt;li&gt;&lt;img src='\"+this.image[i]+\"'&gt;&lt;/li&gt;\").appendTo(this.$imagesUl) &#125; this.$imagesUlLis = this.$imagesUl.find(\"li\"); //布局 this.dom.css(&#123; \"height\" : this.height + \"px\", \"width\" : this.width + \"px\", \"position\" : \"relative\", \"overflow\" : \"hidden\" &#125;) this.$imagesUlLis.css(&#123; \"position\" : \"absolute\", \"left\" : this.width + \"px\", \"top\" : 0, \"list-style\" : \"none\" &#125;) this.$imagesUlLis.eq(0).css(\"left\",0) //创建按钮 this.$leftBtn = $(\"&lt;a href='javascript:;' class='leftBtn'&gt;&lt;/a&gt;\"); this.$rightBtn = $(\"&lt;a href='javascript:;' class='rightBtn'&gt;&lt;/a&gt;\"); this.$leftBtn.appendTo(this.dom); this.$rightBtn.appendTo(this.dom); //小圆点 this.$circleOl =$(\"&lt;ol class='circles'&gt;&lt;/ol&gt;\"); this.$circleOl.appendTo(this.dom); for(var i=0 ;i&lt;this.pictureLength;i++)&#123; $(\"&lt;li&gt;&lt;/li&gt;\").appendTo(this.$circleOl); &#125; this.$circleLis = this.$circleOl.find(\"li\"); this.$circleLis.eq(0).addClass(\"current\"); &#125; //绑定事件 Carousel.prototype.bindEvent = function()&#123; var self = this; this.$rightBtn.click(function()&#123; if(self.$imagesUlLis.is(\":animated\"))&#123; return &#125; self.showNext(); &#125;) this.$leftBtn.click(function()&#123; self.showPrev(); &#125;) this.$circleLis.click(function()&#123; self.show($(this).index()) &#125;) this.dom.mouseenter(function()&#123; clearInterval(self.timer) &#125;); this.dom.mouseleave(function()&#123; self.autoPlay() &#125;); &#125; //显示下一个轮播图 Carousel.prototype.showNext = function()&#123; this.$imagesUlLis.eq(this.index).animate(&#123;\"left\":-this.width&#125;,this.animateDuration) this.index ++ ; this.index = this.index&gt;(this.pictureLength-1)?0:this.index; this.$imagesUlLis.eq(this.index).css(\"left\",this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); this.changeCircles() &#125; //显示上一个轮播图 Carousel.prototype.showPrev = function()&#123; this.$imagesUlLis.eq(this.index).animate(&#123;\"left\":this.width&#125;,this.animateDuration) this.index -- ; this.index = this.index &lt; 0 ?this.pictureLength-1:this.index; this.$imagesUlLis.eq(this.index).css(\"left\",-this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); this.changeCircles() &#125; //点击小圆点切换轮播图 Carousel.prototype.show = function(number)&#123; var old = this.index; this.index = number; if(this.index&gt;old)&#123; this.$imagesUlLis.eq(old).animate(&#123;\"left\":-this.width&#125;,this.animateDuration); this.$imagesUlLis.eq(this.index).css(\"left\",this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); &#125;else&#123; this.$imagesUlLis.eq(old).animate(&#123;\"left\":this.width&#125;,this.animateDuration); this.$imagesUlLis.eq(this.index).css(\"left\",-this.width).animate(&#123;\"left\":0&#125;,this.animateDuration); &#125; this.changeCircles() &#125; //点击小圆点的状态随轮播图的切换而切换 Carousel.prototype.changeCircles = function()&#123; this.$circleLis.eq(this.index).addClass(\"current\").siblings().removeClass(); &#125; //自动播放 Carousel.prototype.autoPlay = function()&#123; var self = this; this.timer =setInterval(function()&#123; self.showNext(); &#125;,this.interval); &#125;&#125;)() 在html文件中引进刚才的carsouel.js文件,创建一个轮播图对象，附加上css样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.11.3/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"Carousel.js\"&gt;&lt;/script&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; #lunbo&#123; margin: 100px auto; &#125; .leftBtn&#123; display: block; width: 40px; height: 50px; background-color: red; position: absolute; left: 0; top: 150px; margin-top: -25px; &#125; .rightBtn&#123; display: block; width: 40px; height: 50px; background-color: red; position: absolute; left: 460px; top: 150px; margin-top: -25px; &#125; .circles&#123; position: absolute; top: 270px; left: 250px; margin-left: -68px; &#125; .circles li&#123; width: 16px; height: 16px; border-radius: 8px; background-color: green; list-style: none; float: left; margin-left: 8px; cursor: pointer; &#125; .circles li.current&#123; background-color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"lunbo\"&gt;&lt;/div&gt; &lt;script&gt; //创建轮播图实例 var c = new Carousel(&#123; \"id\" : \"lunbo\", \"images\":[ \"img/0.png\", \"img/1.png\", \"img/2.png\", \"img/3.png\", \"img/4.png\", \"img/5.png\", ], \"height\" : 300, \"width\" : 500, \"animateDuration\" : 500, \"interval\" : 3000 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"http://yoursite.com/categories/前端开发/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"React中ES6方法创建组件的this","slug":"React中ES6方法创建组件的this","date":"2017-09-04T02:26:14.629Z","updated":"2017-09-04T02:25:27.398Z","comments":true,"path":"2017/09/04/React中ES6方法创建组件的this/","link":"","permalink":"http://yoursite.com/2017/09/04/React中ES6方法创建组件的this/","excerpt":"","text":"学习React的时候，一直为this所困扰，今天就来好好的整理一下，先看一个官方的demo : 12345678910111213141516171819202122232425class LikeButton extends React.Component &#123; constructor() &#123; super(); this.state = &#123; liked: false &#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125; render() &#123; const text = this.state.liked ? 'liked' : 'haven\\'t liked'; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); 重点看第8行和第16行，在 class LikeButton extends React.Component 中我们是声明该class，因为this具体是由其上下文决定的，因此在类定义中我们无法得知this用法。 相当于是new了上面定义的类，首先调用 constructor() 函数， this.state 的this上下文就是该实例对象；同理，render() 函数中 this.state.liked 的this上下文也是该对象。问题在于 onClick={this.handleClick} ，获取该函数引用是没有问题，这里的this上下文就是该对象。 这时问题来了，在原来 React.createClass 中， handleClick() 在onClick事件触发的时候，会自动绑定到LikeButton实例上，这时候该函数的this的上下文就是该实例。不过在ES6的class的写法中，Facebook取消了自动绑定，实例化LikeButton后，handleClick()的上下文是div的支撑实例（ backing instance ），而 handleClick() 原本要绑定的上下文是LikeButton的实例。因此要用到第8行的使用bind()函数改变this的上下文## 使用bind()函数改变this的上下文 总结起来就是：ES6方法创造的React组件并不自动为我们绑定this到当前的实例对象，第8行代码的作用就是通过bind方法让当前的实例中handleClick函数被调用时，this始终是指向当前组件实例。 对于出现的这个问题，我们有两种解决方法 使用bind()函数改变this的上下文 可以在class声明中的constructor()函数中，使用this.handleClick = this.handleClick.bind(this)也就是我们开头提到的方法 除此我们也可以在具体使用该函数的地方绑定this的上下文到LikeButton实例对象，代码如下 123&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; You &#123;text&#125; this. Click to toggle.&lt;/div&gt; 这种方法需要我们每次使用bind()函数绑定到组件对象上。 es6的箭头函数es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用如下代码： 123&lt;div onClick=&#123;() =&gt; this.handleClick()&#125;&gt; You &#123;text&#125; this. Click to toggle.&lt;/div&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"},{"name":"React","slug":"前端开发/React","permalink":"http://yoursite.com/categories/前端开发/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Hexo主题--Human初体验","slug":"Hueman","date":"2017-08-12T08:40:16.027Z","updated":"2017-08-12T08:45:32.099Z","comments":true,"path":"2017/08/12/Hueman/","link":"","permalink":"http://yoursite.com/2017/08/12/Hueman/","excerpt":"","text":"之前折腾过hexo的主题next，相信用hexo搭博客的，很多人都选用next，但在使用的过程中，总感觉next缺少了点什么，之后博客搭起来后，除了前期写了几篇文章，就把它晾在一边，昨晚在简书上搜文章时，发现一个小姐姐的博客搭的挺漂亮的，又给出了详细的搭建过程，于是今天早上一早就起来按照教程，把hexo博客的next主题给换成了hueman主题。 小姐姐的博客在这里 》传送门，还有很多前端干货哦。 更换主题Hueman主题首页 进入hexo的根目录，打开git bash，克隆Hueman到themes文件夹 1$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 修改hexo根目录下的_config.yml文件 1theme: hueman 重命名theme》hueman文件目录下的_config.yml.example为_config.yml (可选项），安装此插件，这样博客可以支持搜索功能，在hexo的根目录下 1$ npm install -S hexo-generator-json-content 最后在hexo根目录执行以下命令就可以把更改部署上GitHub服务器了 123$ hexo clean$ hexo generate$ hexo deploy 配置主题主要是修改头像，网站的favicon，添加评论系统，小姐姐的博客说的很清楚了，这里就不再介绍了，遇到问题也可以到主题的GitHub的issue上给作者留言，很快就可以得到回复的，或者在issue看大家的提问和作者的解答。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"Human","slug":"Human","permalink":"http://yoursite.com/tags/Human/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"用QGIS将shp转json","slug":"用QGIS将shp转json","date":"2017-05-21T14:47:16.000Z","updated":"2017-09-04T06:30:15.843Z","comments":true,"path":"2017/05/21/用QGIS将shp转json/","link":"","permalink":"http://yoursite.com/2017/05/21/用QGIS将shp转json/","excerpt":"","text":"下载 QGIS，QGIS 为开源免费软件，不用破解，安装比较容易，这里就不再列出详细教程。 打开 QGIS Destktop。 添加 vector file，如图箭头所示。更快捷的方法是将 ，将 shp 、dbf 等文件直接拖到 Layers Panel 框里面 。这样就可以跳过步骤 4 直接打开文件了。 弹出选择文件的对话框，Encoding 选择 System，然后点击 Browse，选择 shp 及相关的文件添加进来。（最重要的是 shp 格式的文件和 dbf 格式的文件）。其中步骤 2 点击后如下图所示 打开文件后，点击属性表看一下中文是否乱码打开后的属性表如图所示，没有乱码，如果乱码，一般是因为步骤 4的 Encoding 选项那里选错了。 导出 geojson 文件：在左边的 Layers panel 区域，在任意一个图层右键，选择 Save As。弹出保存文件的对话框，顶部的 Format 选择 geojson，然后点击browse，选择保存文件的路径。点击确定保存。这样就可以把shp转为json了。导出完成后，全选 Layers panel 里面打开的图层文件，右键→remove，即可关闭所打开的图层。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"shp","slug":"shp","permalink":"http://yoursite.com/tags/shp/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"使用gulp编译less","slug":"使用gulp编译less","date":"2017-03-16T17:36:11.796Z","updated":"2017-09-04T02:46:07.498Z","comments":true,"path":"2017/03/17/使用gulp编译less/","link":"","permalink":"http://yoursite.com/2017/03/17/使用gulp编译less/","excerpt":"","text":"学习前端，有时候配置环境，真的是一把辛酸一把泪，虽然网上不乏各式各样详细的教程，但是总有那么一点点的瑕疵，或者是因为自己有些地方理解不了，结果就往往卡在一个地方一筹莫展。 今天的收获 通过慕课网的学习了解了less的作用和编写 安装和配置gulp 使用gulp编译less参考资料 less 即学即用 gulp详细入门教程 gulp新手入门教程 node.js使用gulp编译less 主要步骤1. 安装最新版本的Node.js 新版本的Node.js已集成npm node.js安装-菜鸟教程 2. 全局安装gulp 桌面直接打开Windows的命令行安装，代码如下 1npm install gulp -g 3. 创建gulp项目和局部安装gulp 局部安装与全局安装不同，局部安装需要进入你所需要的前端project的文件夹里面。所以在局部安装之前，需要先在合适的盘建立一个工程文件夹，比如我在E盘的MyCode文件夹里面的ife.baidu文件夹建立了一个task1-9的文件夹，在这个文件夹里面有新建了一个HTML文件，style文件夹，less文件夹等 用Windows的命令行先进入task1-9文件夹 创建gulp项目（就是进入文件夹后再用命令行） 1npm init 然后会出现一大段的文字，提示你输入一些信息，网上找的图：然后就会发现task-1-9文件下多了一个package.json文件。 局部安装gulp（注意同样在文件夹在输入命令行） 1$ npm install gulp --save-dev 然后你的task-1-9文件夹又多了一个node_modules文件夹，里面有好多文件。 4. 本地安装gulp插件（以less插件为例）（文件夹内执行）1npm install gulp-less --save-dev 全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能 5. 新建和编辑gulpfile.js文件 在文件夹下新建一个gulpfile.js文件 然后按照以下说明编写gulpfile.js文件 1234567891011121314151617181920212223242526// 获取 gulpvar gulp = require(&apos;gulp&apos;);// 获取 gulp-less 模块var less = require(&apos;gulp-less&apos;);// 编译less// 在命令行输入 gulp less 启动此任务gulp.task(&apos;less&apos;, function () &#123; // 1. 找到 less 文件，需提前项目文件夹里面新建一个less文件 //再在less文件夹里新建一个less文件，文件的名字可自定义，具体看下图的我的文件结构 gulp.src(&apos;less/*.less&apos;) // 2. 编译为css .pipe(less()) // 3. 另存文件，同理需要在项目文件夹中新建一个style的文件。 .pipe(gulp.dest(&apos;style/css&apos;));&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task(&apos;auto&apos;, function () &#123; // 监听文件修改，当文件被修改则执行 less 任务 gulp.watch(&apos;less/**.less&apos;, [&apos;less&apos;]);&#125;);// 使用 gulp.task(&apos;default&apos;) 定义默认任务// 在命令行使用 gulp 启动 less 任务和 auto 任务gulp.task(&apos;default&apos;, [&apos;less&apos;, &apos;auto&apos;]); 其中的index.css文件是步骤6才生成的。 6. 运行gulp 在项目文件夹中打开命令行，如第5点的代码显示，直接执行以下命令即可,因为default已经包含了less方法和auto方法。 1gulp default 当然也可以分别来执行 12gulp lessgulp auto 运行的结果就是，你可以一边编写less文件，一般自动生成 CSS文件了，赶紧去试一试吧。 补充 gulp中文API 编译less只是gulp功能的一小部分，还有很多功能需要去学习。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"从零开始用Hexo+Github搭建博客","slug":"我的第一篇博客-从零开始用Hexo+Github搭建博客","date":"2017-03-09T17:29:23.609Z","updated":"2017-09-04T02:44:38.656Z","comments":true,"path":"2017/03/10/我的第一篇博客-从零开始用Hexo+Github搭建博客/","link":"","permalink":"http://yoursite.com/2017/03/10/我的第一篇博客-从零开始用Hexo+Github搭建博客/","excerpt":"","text":"昨晚用有道云笔记写Markdown文档的时候，发现Markdown不能插入本地图片，师姐说可以在七牛申请一个服务器，然而又发现申请服务器需要一个域名，于是又去请教师姐，然后师姐说我们可以用GitHub免费搭建一个博客，不需要购买，这两天你们在学习GitHub和Git的操作，那明天的任务就把博客搭出来吧，用Hexo和GitHub…… 写在前面 本教程主要是收集和总结了用Hexo和Github搭建博客过程中所参考的资料，踩过的坑，以及一些注意的事项，并没有详细的写出每一次操作。 主要参考教程 手把手教你用Hexo+GitHub搭建属于自己的博客 使用hexo+github搭建免费个人博客详细教程 在Github上面搭建Hexo博客（一）：部署到Github 基本过程 搭建环境（Node.js和git的安装和配置,GitHub账号设置） 安装Hexo和配置Hexo 将Hexo与GitHub page关联起来 选择主题 主题设置 编写Markdown 1. 搭建环境1.1 Node.js的安装和配置 Node.js安装配置 安装过程中除了修改安装路径外，其他的保持默认设置即可。 安装完成后，检查一下是否安装成功，同时按下Win和R键，打开运行窗口，输入cmd，回车打开命令行界面，输入 12node -vnpm -v 如果出现node和npm的版本号，则表示安装成功了 之前失败过一次，后来卸载了重装就成功了哈哈1.2 Git的安装和配置 Git安装 Git教程1.3 GitHub账号设置 申请GitHub账号 创建GitHub仓库（这个仓库和平时的GitHub仓库不同，命名的格式是gourname.github.io，如我的github的全名为xiaoxiongzi，那仓库的命名就为xiaoxiongzi.github.io） ==重点难点：将本地仓库和远程仓库关联起来== 2. 安装Hexo和配置Hexo 可以参考教程手把手教你用Hexo+GitHub搭建属于自己的博客 Hexo的相关配置 初始Hexo 1hexo init 安装npm组件 1npm install 体验Hexo 1hexo g 1hexo s 出现相关提示，在浏览器中打开就可以了。 3. 将Hexo与GitHub page 联系起来1. 配置Deployment，将本地的文件部署（上传）到Github账户中 编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码（在你修改时，把 xiaoxiongzi要替换成你自己的用户名） 1234deploy: type: git repository: http://github.com/xiaoxiongzi/xiaoxiongzi.github.io.git branch: master .yml文件对格式规范要求很严格，type: repository: branch: 前面有两个空格，冒号后面都有一个空格。 执行以下指令即可完成部署（如果提示错误，可以看下面注意）：12$ hexo generate$ hexo deploy 2.配置SSH 具体可以参考在Github上面搭建Hexo博客（一）：部署到Github的配置SSH部分。 4. 使用Hexo写博客 Hexo官网 主题推荐NexT 具体过程请参考使用hexo+github搭建免费个人博客详细教程","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]}]}